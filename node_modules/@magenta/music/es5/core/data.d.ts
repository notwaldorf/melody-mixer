import * as tf from '@tensorflow/tfjs-core';
import { INoteSequence, NoteSequence } from '../protobuf/index';
export declare const DEFAULT_DRUM_PITCH_CLASSES: number[][];
export interface MelodyConverterSpec {
    type: 'MelodyConverter';
    args: MelodyConverterArgs;
}
export interface DrumsConverterSpec {
    type: 'DrumsConverter';
    args: DrumsConverterArgs;
}
export interface DrumRollConverterSpec {
    type: 'DrumRollConverter';
    args: DrumsConverterArgs;
}
export interface TrioConverterSpec {
    type: 'TrioConverter';
    args: TrioConverterArgs;
}
export interface DrumsOneHotConverterSpec {
    type: 'DrumsOneHotConverter';
    args: DrumsConverterArgs;
}
export interface MultitrackConverterSpec {
    type: 'MultitrackConverter';
    args: MultitrackConverterArgs;
}
export declare type ConverterSpec = MelodyConverterSpec | DrumsConverterSpec | DrumRollConverterSpec | TrioConverterSpec | DrumsOneHotConverterSpec | MultitrackConverterSpec;
export declare function converterFromSpec(spec: ConverterSpec): DataConverter;
export interface BaseConverterArgs {
    numSteps?: number;
    numSegments?: number;
}
export declare abstract class DataConverter {
    readonly numSteps: number;
    readonly numSegments: number;
    abstract readonly depth: number;
    abstract readonly endTensor: tf.Tensor1D;
    abstract readonly NUM_SPLITS: number;
    abstract readonly SEGMENTED_BY_TRACK: boolean;
    abstract toTensor(noteSequence: INoteSequence): tf.Tensor2D;
    abstract toNoteSequence(tensor: tf.Tensor2D, stepsPerQuarter: number): Promise<INoteSequence>;
    constructor(args: BaseConverterArgs);
    tensorSteps(tensor: tf.Tensor2D): tf.Scalar;
}
export interface DrumsConverterArgs extends BaseConverterArgs {
    pitchClasses?: number[][];
}
export declare class DrumsConverter extends DataConverter {
    readonly pitchClasses: number[][];
    readonly pitchToClass: Map<number, number>;
    readonly NUM_SPLITS: number;
    readonly SEGMENTED_BY_TRACK: boolean;
    readonly depth: number;
    readonly endTensor: tf.Tensor1D;
    constructor(args: DrumsConverterArgs);
    toTensor(noteSequence: INoteSequence): tf.Tensor<tf.Rank.R2>;
    toNoteSequence(oh: tf.Tensor2D, stepsPerQuarter?: number): Promise<NoteSequence>;
}
export declare class DrumRollConverter extends DrumsConverter {
    toNoteSequence(roll: tf.Tensor2D, stepsPerQuarter?: number): Promise<NoteSequence>;
}
export declare class DrumsOneHotConverter extends DrumsConverter {
    readonly depth: number;
    constructor(args: DrumsConverterArgs);
    toTensor(noteSequence: INoteSequence): tf.Tensor<tf.Rank.R2>;
}
export interface MelodyConverterArgs extends BaseConverterArgs {
    minPitch: number;
    maxPitch: number;
    ignorePolyphony?: boolean;
}
export declare class MelodyConverter extends DataConverter {
    readonly minPitch: number;
    readonly maxPitch: number;
    readonly ignorePolyphony: boolean;
    readonly depth: number;
    readonly endTensor: tf.Tensor1D;
    readonly NUM_SPLITS: number;
    readonly SEGMENTED_BY_TRACK: boolean;
    readonly NOTE_OFF: number;
    readonly FIRST_PITCH: number;
    constructor(args: MelodyConverterArgs);
    toTensor(noteSequence: INoteSequence): tf.Tensor<tf.Rank.R2>;
    toNoteSequence(oh: tf.Tensor2D, stepsPerQuarter?: number): Promise<NoteSequence>;
}
export interface TrioConverterArgs extends BaseConverterArgs {
    melArgs: MelodyConverterArgs;
    bassArgs: MelodyConverterArgs;
    drumsArgs: DrumsConverterArgs;
}
export declare class TrioConverter extends DataConverter {
    melConverter: MelodyConverter;
    bassConverter: MelodyConverter;
    drumsConverter: DrumsConverter;
    readonly depth: number;
    readonly endTensor: tf.Tensor1D;
    readonly NUM_SPLITS: number;
    readonly SEGMENTED_BY_TRACK: boolean;
    readonly MEL_PROG_RANGE: number[];
    readonly BASS_PROG_RANGE: number[];
    constructor(args: TrioConverterArgs);
    toTensor(noteSequence: INoteSequence): tf.Tensor<tf.Rank.R2>;
    toNoteSequence(th: tf.Tensor2D, stepsPerQuarter?: number): Promise<NoteSequence>;
}
export interface MultitrackConverterArgs extends BaseConverterArgs {
    stepsPerQuarter: number;
    totalSteps: number;
    numVelocityBins: number;
    minPitch?: number;
    maxPitch?: number;
}
export declare class MultitrackConverter extends DataConverter {
    readonly NUM_SPLITS: number;
    readonly SEGMENTED_BY_TRACK: boolean;
    readonly stepsPerQuarter: number;
    readonly totalSteps: number;
    readonly numVelocityBins: number;
    readonly minPitch: number;
    readonly maxPitch: number;
    readonly numPitches: number;
    readonly performanceEventDepth: number;
    readonly numPrograms: number;
    readonly endToken: number;
    readonly depth: number;
    readonly endTensor: tf.Tensor1D;
    constructor(args: MultitrackConverterArgs);
    private trackToTensor;
    toTensor(noteSequence: INoteSequence): tf.Tensor<tf.Rank.R2>;
    private tokensToTrack;
    toNoteSequence(oh: tf.Tensor2D, stepsPerQuarter?: number): Promise<NoteSequence>;
}
